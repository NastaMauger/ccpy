

!!!! diagram 13: h2b(mcek)*t3a(abeijm) !!!!
! allocate and initialize the copy of t3a
allocate(t3_amps_buff(n3aaa))
allocate(t3_excits_buff(6,n3aaa))
t3_amps_buff(:) = t3_amps_buff(:)
t3_excits_buff(:,:) = t3_excits_buff(:,:)
! allocate sorting arrays (can be reused for each permutation)
allocate(loc_arr(nua*(nua-1)/2*noa*(noa-1)/2,2))
allocate(idx_table(nua,nua,noa,noa))
!!! ABIJ LOOP !!!
call sort_t3a_abij(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j)
   if (idx==0) cycle 
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      f = t3_excits_buff(3,jdet); n = t3_excits_buff(6,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | ijnabf >
      hmatel = h2b_ovvo(n,c,f,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! ACIJ LOOP !!!
call sort_t3a_acij(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      e = t3_excits_buff(2,jdet); n = t3_excits_buff(6,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | ijnaeb >
      hmatel = -h2b_ovvo(n,c,e,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! BCIJ LOOP !!!
call sort_t3a_bcij(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      d = t3_excits_buff(1,jdet); n = t3_excits_buff(6,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | ijndab >
      hmatel = h2b_ovvo(n,c,d,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! ABIK LOOP !!!
call sort_t3a_abik(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      f = t3_excits_buff(3,jdet); m = t3_excits_buff(5,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | imjabf >
      hmatel = -h2b_ovvo(m,c,f,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! ACIK LOOP !!!
call sort_t3a_acik(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      d = t3_excits_buff(1,jdet); m = t3_excits_buff(5,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | imjaeb >
      hmatel = h2b_ovvo(m,c,e,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! BCIK LOOP !!!
call sort_t3a_bcik(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      d = t3_excits_buff(1,jdet); m = t3_excits_buff(5,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | imjdab >
      hmatel = -h2b_ovvo(m,c,d,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! ABJK LOOP !!!
call sort_t3a_abjk(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      f = t3_excits_buff(3,jdet); l = t3_excits_buff(4,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | lijabf >
      hmatel = h2b_ovvo(l,c,f,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! ACJK LOOP !!!
call sort_t3a_acjk(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      e = t3_excits_buff(2,jdet); l = t3_excits_buff(4,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | lijaeb >
      hmatel = -h2b_ovvo(l,c,e,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do 
!!! BCJK LOOP !!!
call sort_t3a_bcjk(t3_excits_buff, t3_amps_buff, loc_arr, idx_table, noa, nua, n3aaa)
do idet = 1, n3aab
   a = t3b_excits(1,idet); b = t3b_excits(2,idet); c = t3b_excits(3,idet);
   i = t3b_excits(4,idet); j = t3b_excits(5,idet); k = t3b_excits(6,idet);
   idx = idx_table(a,b,i,j) 
   if (idx==0) cycle
   do jdet = loc_arr(idx,1), loc_arr(idx,2)
      d = t3_excits_buff(1,jdet); l = t3_excits_buff(4,jdet);
      ! compute < ijk~abc~ | h2b(ovvo) | lijdab >
      hmatel = h2b_ovvo(l,c,d,k)
      resid(idet) = resid(idet) + hmatel * t3_amps_buff(jdet)
   end do
end do
! deallocate sorting arrays
deallocate(loc_arr,idx_table)
! deallocate t3 buffer arrays
deallocate(t3_amps_buff,t3_excits_buff) 


      ! [TODO]:
      ! Before going futher, we should make a generic routine for a collective
      ! sort, meaning something like
         subroutine sort4_t3b(t3b_excits, t3b_amps, id_arr, table, dims, t3_shape, id_len, n3aab, resid)
      
              integer, intent(in) :: n3aab, id_len
              integer, intent(in) :: t3_shape(6)
              integer, intent(in) :: dims(4) ! length of this defines the integer in sort*_t3b

              integer, intent(inout) :: t3b_excits(6,n3aab)
              real(kind=8), intent(inout) :: t3b_amps(n3aab)
              real(kind=8), intent(inout), optional :: resid(n3aab)
              integer, intent(inout) :: table(t3_shape(dims(1)),t3_shape(dims(2)),t3_shape(dims(3)),t3_shape(dims(4))
              integer, intent(inout) :: id_arr(id_len,2)

              integer :: kout, idet
              integer :: i, j, k, a
              integer :: i1, j1, k1, a1, i2, j2, k2, a2
              integer :: aijk, aijk1, aijk2
              integer, allocatable :: temp(:), idx(:)

              ! Need information about which dimensions are ordered
              table = 0
              kout = 1
              do i1 = 1, t3_shape(dims(1))
                 do i2 = 1, t3_shape(dims(2))
                    do i3 = 1, t3_shape(dims(3))
                       do i4 = 1, t3_shape(dims(4))
                          table(i1,i2,i3,i4) = kout
                          kout = kout + 1
                       end do
                    end do
                 end do
              end do

              allocate(temp(n3aab),idx(n3aab))
              do idet = 1, n3aab
                 temp(idet) = XaXiXjXk_table(t3_excits(dims(1),idet),t3_excits(dims(2),idet),t3_excits(dims(3),idet),t3_excits(dims(4),idet))
              end do
              call argsort(temp, idx)
              t3b_excits = t3b_excits(:,idx)
              t3b_amps = t3b_amps(idx)
              if (present(resid)) resid = resid(idx)
              deallocate(temp,idx)

              id_arr = 1
              do idet = 2, n3aab
                 p = XaXiXjXk_table(t3_excits(dims(1),idet-1),t3_excits(dims(2),idet-1),t3_excits(dims(3),idet-1),t3_excits(dims(4),idet-1))
                 q = XaXiXjXk_table(t3_excits(dims(1),idet),t3_excits(dims(2),idet),t3_excits(dims(3),idet),t3_excits(dims(4),idet))
                 if ( p /= q ) then
                         ID(p,2) = idet - 1
                         ID(q,1) = idet
                 end if
              end do
              ID(q,2) = n3aab

         end subroutine sort4_t3b
